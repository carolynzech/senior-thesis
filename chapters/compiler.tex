\section{Compiler}

The \syslang{} compiler translates policies into graph queries over \sys{}'s PDG,
which \devs{} run against their application.
%
The compiler first parses the policy into an abstract syntax tree (AST).
%
It then traverses this AST to verify that the policy is properly scoped.
%
It errors if any variables are used in a relation without first being introduced by an iterator or definition.
%
It also prohibits duplicate introductions of the same variable in the same scope.

Once the compiler verifies that the policy is properly scoped,
it performs a second pass over the AST to compile it to Rust code.
%
It performs compilation via template expansion.
%
It identifies the relevant template for each node in the AST,
substituting in the policy's variables and markers.
%
The |and|, |or|, |for each|, |there is|, and |if| constructs correspond directly to Rust builtin operators.
%
Relations compile to expressions using \sys{}'s Graph Query API.
%
For example, \lstinline[language=CNL]|"x" goes to "y"| compiles to |flows_to(x, y, EdgeSelection::Data)|.
%
The compiler outputs a binary file containing the policy.
%
This binary contains boilerplate code to invoke \sys{} against the policy,
which the \dev{} edits to provide application-specific information,
such as the application directory
and optional \sys{} configuration flags.
%
