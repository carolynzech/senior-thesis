\chapter{Implementation}
\label{sec:limitations}
We implement the \syslang{} compiler in 2370 lines of Rust.

\syslang{} has some limitations which could be overcome with further engineering effort.
%
We detail those below.

\section{Direct Dependencies}
\syslang{} relations reason about \emph{transitive} dependencies between PDG nodes.
%
There is no way for \ces{} to enforce a \emph{direct} edge between two nodes (i.e., no intermediate data or control flow).
%
In most cases, transitive dependencies are the correct level of abstraction.
%
For example, given the code \lstinline[language=Rust]|sink(*sensitive)|,
one would reasonably conclude that |sensitive| goes to |sink|.
%
However, since |sensitive| is dereferenced, the PDG would contain an intermediate node between |sensitive| and |sink|,
so there is no direct data flow edge between |sensitive| and |sink|.\carolyn{verify w justus}
%
However, it is possible that a \dev{} would want to forbid any intermediate data transformations
to secret data before it reaches some |sink| (perhaps in a security-critical setting).
%
\syslang{} could not express this policy, while \sys{}'s Graph Query API can.

\section{Code Optimization}
The \syslang{} compiler does not optimize its outputted code, so it misses opportunities for efficiency improvements.
%
For example, if a policy contains two iterators over the same data, the \syslang{} compiled policy will traverse the PDG twice to gather the relevant nodes,
when it could have just done one traversal and stored the result for the subsequent iteration.
%
Our \syslang{} prototype supports five levels of bullets, although more could be supported with additional engineering effort.
