\section{Surface Language}
\label{sec:interface}

A \syslang{} policy has two to three sections: its scope, (optionally) its definitions, and its body.

\subsection{Scope}
\label{sec:scope}

A \ce{} has three options for the scope of their policy:
%
\begin{enumerate}[nosep]
    \item \emph{Everywhere} indicates that every \controller{} should obey the policy.
    \item \emph{Somewhere} indicates that at least one \controller{} should obey the policy.
    \item \emph{In} |name| indicates that the \controller{} with name |name| should obey the policy.
\end{enumerate}

The appropriate scope is policy-dependent.
%
For instance, if an application should always encrypt sensitive data before storage,
the \ce{} should select an ``Everywhere'' scope.
%
For a GDPR data deletion policy, however, an ``Everywhere'' scope would not make sense, 
since that would require every \controller{} storing user data to also delete it.
%
Instead, such a policy could use a ``Somewhere'' scope to mandate that at least one \controller{} deletes user data.
%
\Ces{} may wish to be more specific and ensure that a particular \controller{} deletes user data as specified,
in which case they should use the \emph{In} |name| scope.
%
This scope achieves greater precision, but is also tied to the source code; if the name of the data deletion \controller{} changes, the policy must change as well.
%

\subsection{Definitions}
\label{sec:definitions}

In the Freedit example from \S\ref{sec:overview}, the \ce{}'s final policy was:
\begin{lstlisting}[language=CNL]
For each "view" marked @@views@@:
  For each "database store" marked @@store@@:
    If "view" goes to "database store" then:
      There is a "date" marked @@time@@ where:
        "date" goes to "database store"
\end{lstlisting}
This policy contains five levels of nesting.
%
As policies get more complex, many levels of nesting can make policies inefficient and harder to understand.
%
To address this issue, \syslang{} allows \ces{} to create \emph{definitions}.
%
A definition defines a variable ahead of time which refers to all nodes in a given \controller{}'s PDG that meet a certain condition.
%
Observe that the Freedit policy does not enforce any obligations on a \lstinline[language=CNL]|"database store"| unless it stores a \lstinline[language=CNL]|"view"|.
%
Rather than iterate through \emph{all} database stores, 
a \writer{} can collect only the relevant database stores up front,
then write their policy in terms of those.
%
In this case, the Freedit \ce{} would create the following definition:
\begin{lstlisting}[language=CNL]
"view store" is each "store" marked @@db_store@@ where:
  There is a "view" marked @@views@@ where:
    "view" goes to "store"
\end{lstlisting}
and revise their policy to:
\begin{lstlisting}[language=CNL]
For each "view store":
  There is a "date" marked time where:
    "date" goes to "view store" 
\end{lstlisting}
This policy is also more efficient because it avoids the double ``for each'' loop of the original,
which may be expensive in an application that has many \lstinline[language=CNL]|"view"|s or \lstinline[language=CNL]|"database store"|s.
%

Since \sys{} constructs per-\controller{} PDGs,
\syslang{} policies, once compiled, are evaluated against one \controller{} at a time.
%
The scope of the policy dictates which \controller{}(s) must uphold the policy.
%
Since policy bodies only consider nodes in the current \controller{}'s PDGs,
definitions are also, by default, \controller{}-specific

By default, definitions are also evaluated on a per-\controller{} basis.
%
However, a \ce{} may want to gather all nodes meeting a certain condition \emph{across \controller{}s}.
%
For instance, consider a policy that states that for each |sensitive| type that the application |store|s,
that type is also |delete|d.
%
It is unlikely that a single \controller{} would both store the sensitive data \emph{and} delete it.
%
Instead, the \ce{} could declare a definition to gather the relevant types from across the application,
then write a policy that states that some \controller{} must delete those types.
%
They would do so by appending ``anywhere in the application'' to their definition declaration,

% Such a policy would look like the following:
% \begin{figure}[h]
% \begin{lstlisting}[language=CNL]
% Scope: Somewhere

% Definitions:
% "stored sensitive" is each "sensitive" type marked @@sensitive@@ where, 
% anywhere in the application:
%     There is "database store" marked @@store@@ where:
%       "sensitive" goes to "database store"

% Policy:
% For each "stored sensitive":
%     There is a "deleter" marked @@deletes@@ where:
%       "stored sensitive" goes to "deleter"
% \end{lstlisting}
% \end{figure}

\begin{figure}[t]
    \small
    \begin{tabular}{|p{5.5cm}|p{8cm}|}
        \hline
        \syslang{} Relation                                                       &  Obligation on PDG                   \\ \hline
        \lstinline[language=CNL]|"a" goes to "b"|                                 &  There is some transitive data flow dependency from
                                                                                    \lstinline[language=CNL]|"a"| to \lstinline[language=CNL]|"b"|. \\
        \hline
        \lstinline[language=CNL]|"a" affects whether "b" happens|                 & There is some transitive control flow dependency from
                                                                                    \lstinline[language=CNL]|"a"| to \lstinline[language=CNL]|"b"|. \\
        
        \hline
        \lstinline[language=CNL]|"a" goes to "b" only via "c"|                    &  On every data path from \lstinline[language=CNL]|"a"| to \lstinline[language=CNL]|"b"|,
                                                                                    \lstinline[language=CNL]|"a"| passes through \lstinline[language=CNL]|"c"|. \\
        \hline
        \lstinline[language=CNL]|"a" influences "b"|                              &  There is some transitive data flow and/or control flow dependency from  \lstinline[language=CNL]|"a"| to \lstinline[language=CNL]|"b"|.  \\
        \hline
        \lstinline[language=CNL]|"a" is marked @@m@@|                             & \lstinline[language=CNL]|"a"| is marked \lstinline[language=CNL]|@@m@@|. \\
        \hline
        \lstinline[language=CNL]|"a" goes to "b"'s operation|                     & \lstinline[language=CNL]|"a"| goes to the call site associated with \lstinline[language=CNL]|"b"|,
                                                                                    e.g., if \lstinline[language=CNL]|"b"| is an argument to a call site, then \lstinline[language=CNL]|"a"| goes to any of that call site's arguments or return. \\        
      \hline
    \end{tabular}
      \caption{\syslang's relations and the obligations they enforce on \sys's marked PDG.}
      \label{f:relations}
  \end{figure}

\subsection{Body}
\label{sec:body}

The policy body has three components: iterators, relations, and conjunctions/disjunctions of them.
%
\paragraph{Iterators: }
Iterators allow \ces{} to loop over a collection of nodes, reasoning about one node at a time.
%
\syslang{} provides two iterators: a ``For each'' loop or a ``There is'' statement.
%
To iterate over a defined variable \lstinline[language=CNL]|"x"|, 
a \ce{} would write \lstinline[language=CNL]|For each "x" marked @@m@@:| or \lstinline[language=CNL]|There is a "x" marked @@m@@ where:|
%
To introduce a new variable,
a \ce{} would write \lstinline[language=CNL]|For each "x" marked @@m@@:| or \lstinline[language=CNL]|There is a "x" marked @@m@@ where:|
%
A ``For each'' loop iterates over each object in the collection and evaluates the body of the loop 
in the context of the current object \lstinline[language=CNL]|"x"|.
%
It succeeds if the body is true for all \lstinline[language=CNL]|"x"|.
%
If there are no objects in the collection, the policy is vacuously true.
%
\syslang{} allows for vacuity because it evaluates policies on a per-\controller{} basis,
and some \controller{}s may not have certain markers.
%
For example, take the Freedit policy from \S\ref{sec:overview}:
\begin{lstlisting}[language=CNL]
Scope: Everywhere

Policy:
For each "view" marked @@views@@:
  For each "database store" marked @@store@@:
    If "view" goes to "database store" then:
      There is a "date" marked @@time@@ where:
        "date" goes to "database store"
\end{lstlisting}

Since the policy's scope is ``Everywhere'', it will be evaluated against every \controller{},
regardless of whether it handles view data.
%
It would be confusing for a \dev{} if their application failed the policy on a \controller{} 
that does not even contain the \lstinline[language=CNL]|@@views@@|.
%
The \ce{} could avoid this problem by changing their scope to list every \controller{} to which they expect the policy to apply,
but that would defeat \syslang's goal of being independent from source code.
%
If the \ce{} wants to insert such a vacuity check, they can leverage the ``There is'' iterator, like so:
\begin{lstlisting}[language=CNL]
  Scope: Everywhere
  
  Policy:
  There is a "view" marked @@views@@ where:
    There is a "database store" marked @@store@@ where:
      "view" goes to "database store"
  and
  For each "view" marked @@views@@:
    For each "database store" marked @@store@@:
      If "view" goes to "database store" then:
        There is a "date" marked @@time@@ where:
          "date" goes to "database store"
\end{lstlisting}
%
The ``There is'' iterator succeeds if the body is true for at least one \lstinline[language=CNL]|"x"|.
%
If there are no objects in the collection, the policy is false.
%
Observe that the loop bodies reason about the iterator variables.
%
If instead, we eschewed iterators and wrote this policy as:
\begin{lstlisting}[language=CNL]
If "view" goes to a "database store" marked @@store@@:
  There is a "date" marked @@time@@ where:
    "date" goes to a "database store" marked @@store@@
\end{lstlisting}
We would not enforce that \lstinline[language=CNL]|"view"| and \lstinline[language=CNL]|"date"| 
go to the \emph{same} \lstinline[language=CNL]|"database store"|.
%
This policy, however, would pass as long as the date is stored anywhere else in the application,
even if it is in a context completely unrelated to views.
%
Iterators enable for the correct version of the policy by allowing \ces{} to refer to the same object multiple times.

\paragraph{Relations: }
%
Relations are between two objects: either two variables and a variable and a marker.
%
The full list of available relations are in Figure~\ref{f:relations}.
%
\syslang{} also supports the negation of each of these relations, e.g. \lstinline[language=CNL]|"a" does not go to "b"|.
%
\Ces{} use |and| or |or| operators to join iterators or relations together.

\Ces{} also need to indicate the scope of each iterator.
%
In our examples thus far, we have used indentation to nest iterators.
%
However, such a design is error-prone--one accidental indentation, and a \ce{} compiles an entirely different policy than what they intended.
%
For instance, take the policies in Figure~\ref{f:indentation}, which differ only in indentation but have different meanings.
%
Version (1) will only enforce that the sensitive value is encrypted if it is stored.
%
Version (2) enforces that the sensitive value is encrypted regardless.

\begin{figure}[t]
    \begin{subfigure}[b]{\columnwidth}
  \begin{lstlisting}[language=CNL]
    If "sensitive" goes to "store" then:
      "sensitive" goes to "auth check"
      and
      "sensitive" goes to "encrypts"
  \end{lstlisting}
  \caption{Version 1 of the policy.}
  \end{subfigure}
  \begin{subfigure}[b]{\columnwidth}
  \begin{lstlisting}[language=CNL]
    If "sensitive" goes to "store" then:
      "sensitive" goes to "auth check"
    and
    "sensitive" goes to "encrypts"
    \end{lstlisting}
    \caption{Version 2 of the policy.}
    \end{subfigure}
    \caption{Two policies with identical syntax but different scopes. These policies are partial; we elide iterator declarations for brevity.}
    \label{f:indentation}
\end{figure}

\begin{figure}[t]
    \begin{subfigure}[b]{\columnwidth}
  \begin{lstlisting}[language=CNL]
    1. If "sensitive" goes to "store" then:
      A. "sensitive" goes to "auth check"
      and
      B. "sensitive" goes to "encrypts"
  \end{lstlisting}
  \caption{Version 1 of the policy.}
  \end{subfigure}
  \begin{subfigure}[b]{\columnwidth}
  \begin{lstlisting}[language=CNL]
    1. If "sensitive" goes to "store" then:
      A. "sensitive" goes to "auth check"
    and
    2. "sensitive" goes to "encrypts"
    \end{lstlisting}
    \caption{Version 2 of the policy.}
    \end{subfigure}
    \caption{The policies from Figure~\ref{f:indentation} with bullets to explicitly delineate each expressions's scope.}
    \label{f:bullets}
\end{figure}

Rather than allow a stray indent to change the meaning of the policy,
\syslang{} instead enforces that \ces{} explicitly specify the scope of each statement.
%
They do so using \emph{bullets}.
%
Figure~\ref{f:bullets} shows the policies from Figure~\ref{f:indentation} with \syslang{} bullets.
%
\Ces{} are not permitted to mix operators (|and|s and |or|s) on the same bullet level,
since the operator precedence in such cases would be ambiguous.

\paragraph{Source Code Entities: }
\carolyn{This is oddly placed, but I can't think of a better location for it 
at the moment and it's necessary background for the precision eval. Feels too long to put in the eval itself.}
\syslang{} intentionally abstracts away details of the PDG to make policies easier to write.

Namely, \syslang{} does not support reasoning about particular source code entities (e.g., arguments, functions).
%
The one exception is types.
%
% Unlike arguments and return values, marked types do not belong to a particular controller. 
%
A typical data deletion policy will take the following form:
\begin{lstlisting}[language=CNL]
1. For each "sensitive" type marked @@user_data@@:
  A. There is a "source" that produces "sensitive" where:
    a. There is a "deleter" marked @@deletes@@ where:
        i) "source" goes to "deleter"
\end{lstlisting}
The policy needs to iterate over each marked type,
\emph{then} ensure that some node in the PDG is both \emph{(i)} of that type
and \emph{(ii)} has that marker.
%
Consider how a \ce{} would write this policy without the |type| keyword.
%
They could write just that \lstinline[language=CNL]|There is a "source" marked @@user_data@@|,
but that does not ensure that \emph{all} @@user_data@ types are deleted.
%
They could approximate the |type| keyword by giving each type a unique marker and using \lstinline[language=CNL]|There is|
iterators for each of them, but such a policy would be tedious to write and easy to get wrong.
%
For other kinds of marked source code entities (arguments and return values),
there is no compelling need to iterate over each variant of them.
%
It is harder to imagine, for example, a policy that would need to distinguish between 
a |u32| and a |String| marked \lstinline[language=CNL]|@@sensitive@@|.
%
\syslang{} therefore does not support reasoning about arguments or return values directly.

\syslang{}'s full grammar is in \Cref{sec:grammar}.
