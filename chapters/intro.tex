\chapter{Introduction}
\label{sec:intro}

Privacy bugs in applications hurt users (e.g., by leaking their sensitive data) and put software providers 
at risk for financial liability.
%
In May of 2023 alone, Ireland fined Meta €1.2 billion for GDPR violations, 
while the United States fined Amazon \$25 million for failing to honor data deletion requests 
under the Children’s Online Privacy Protection Act\cite{meta-fine,amazon-fine}.
%
To ensure compliance, organizations must relate dense legal text to their low-level application source code.
%
Currently, software providers use manual audits to verify compliance, which are expensive, time-consuming,
and infrequent~\cite{CostContinuousCompliance2020,smithGDPRRacketWho}.

\sys{} is a static analyzer for Rust applications that \devs{} leverage to find such bugs in their programs before deployment.
%
\sys{} evaluates an application by generating its program dependence graph (PDG), 
where nodes are program entities (functions, arguments, etc.) and edges are control or data flow dependencies.
%
\sys{} evaluates the PDG against the policy and outputs whether the application is compliant.
%
We imagine that \devs{} run \sys{} continually throughout the development process, perhaps as part of a CI pipeline.

\section{The Problem}
Ideally, \writers{} could specify policies at a high level (e.g., ``all sensitive data is encrypted before it exits the application'').
%
Such a high-level specification is clear, concise, and portable across applications.
%
Prior to this work, however, \sys{} did not support this level of policy abstraction.
%
Instead, policies were Rust programs that executed low-level graph queries over the application's PDG.
%
This design limited the available pool of policy writers to those with an in-depth understanding of Rust programming and \sys{}'s PDG representation.
%
Since policies were programs, they had the same problems as the applications they evaluated: 
they were buggy, laborious to write, and comprehensible only to programmers familiar with the application.
%

We address this issue with \syslang{}, a DSL for \policies{} over PDGs.
%
\syslang{} is a Controlled Natural Language (CNL) interface; users write policies in natural language, but are restricted to a defined grammar. ~\cite{cnl-def}
%
Natural language offers the intuitive quality we sought, while the grammar allowed us to avoid the ambiguity of unconstrained English.
%
We pair \syslang{} with a compiler that translates policies to \sys{} graph queries in Rust.
%
\Devs{} then invoke \sys{} on their application,
which will generate its PDG, evaluate it against the compiled \syslang{} policy,
and output whether the application is compliant.
%

\section{Goals}
\syslang{} must address a few challenges.

First, it must be accessible yet unambiguous.
%
\syslang{} should not require policy writers to reason about low-level source code entities, such as particular functions or arguments.
%
Such a design would tie the policy to the application's implementation, effectively restricting policy writing to the application's \devs.
%
It would also make the policies more difficult to write, brittle to source code changes, and less portable across applications.
%
\syslang{} should instead be accessible to a broader range of technical stakeholders.
%
Ideally, a \ce--someone who knows how to program, 
but who is not necessarily familiar with the particular implementation details--would write policies.
%
% Larger organizations have dedicated compliance teams that could write such policies.~\cite{todo}
% %
% In smaller organizations, the \ce{} could be a team's manager.\carolyn{this level of detail is probably not necessary}
% %
% Natural language is the most obvious intuitive structure for specifying these policies, 
% especially since privacy regulations are specified in natural language.\carolyn{I don't like this sentence.}
% %
% However, natural language is also ambiguous.
% %
% 
% %
% Programming languages have well-known constructs for handling such ambiguity, such as parenthesized expressions or operator precedence rules.~\cite{todo}
% %
Natural language is an obvious intuitive structure for specifying these policies.
%
However, unconstrained natural language can be ambiguous, which is unacceptable for a privacy policy.
%
For example, the sentence ``|A| or |B| and |C|'' is vague; which operator should take higher precedence?
%
\syslang{} must reject ambiguous policies while not becoming so onerous to use that it 
requires the same expertise and time investment as writing a graph query program.

Second, \syslang{} should be expressive.
%
A trivial way of eliminating ambiguity would be to define a highly restricted natural language interface that allows for only a handful of policy formulations.
%
This structure, however, would not be expressive enough to meet the needs of complex applications, 
which must abide by a wide range of privacy requirements.
%
Instead, \syslang{} should be flexible enough to apply across policy and application domains.

Third, \syslang{} should be precise.
%
\sys{}'s PDG representation represents program structure at a high level of precision.
%
% It can reason about the dependencies of each distinct function argument or fields of a type.\carolyn{confusing sentence}
%
With the existing graph query interface, \writers{} can leverage this precision to make highly specific queries
(e.g., count the exact number edges between two nodes in a graph). 
%
However, \policies{} often do not require this level of precision.
%
If \syslang{} were to support such precise queries over the PDG, it would not be accessible--\ces{} would require expertise
to choose from a wide array of query patterns over a complex, unfamiliar data strucutre.
%
However, if policies are not sufficiently precise, they are more likely to produce false positives or false negatives when run against application code.
%
\syslang{} should support sufficiently precise queries to express common \policies{}, 
while not overwhelming the \writer{} with the full power of \sys{}'s PDG representation. 

Fourth, \syslang{} policies, once compiled, should be similarly efficient to graph queries originally written in Rust.
%
This goal is necessary so that \sys{} remains practical for CI use.

We evaluate \syslang{} against seven third-party Rust applications.
%
We find that \syslang{} can express a wide range of \policies{} for these applications,
that these policies are accessible and portable across applications,
and that they incur acceptable run time overhead compared to optimized Rust graph queries.
%

\emph{\sys{} and its Graph Query API is the product of collaboration with Justus Adam, Livia Zhu, Sreshtaa Rajesh, 
Will Crichton, Shriram Krishnamurthi, and Malte Schwarzkopf.
My contribution specifically is the \syslang{} policy language and the compilation to Rust policies.}
